<>// from: https://gist.github.com/michaellihs/a6621376393821d6d206ccfc8dbf86ec

buildscript {
    repositories {
        jcenter {
            url "https://jcenter.bintray.com/"
        }
    }
    dependencies {
        classpath 'org.ajoberstar.grgit:grgit-core:3.1.1'
    }
}

enum PatchLevel {
    MAJOR, MINOR, PATCH
}

class SemVer implements Serializable {

    private int major, minor, patch

    SemVer(String version) {
        def versionParts = version.tokenize('.')
        if (versionParts.size != 3) {
            throw new IllegalArgumentException("Wrong version format - expected MAJOR.MINOR.PATCH - got ${version}")
        }

        this.major = versionParts[0].toInteger()
        this.minor = versionParts[1].toInteger()
        this.patch = versionParts[2].toInteger()
    }

    SemVer(int major, int minor, int patch) {
        this.major = major
        this.minor = minor
        this.patch = patch
    }

    SemVer bump(PatchLevel patchLevel) {
        switch (patchLevel) {
            case PatchLevel.MAJOR:
                return new SemVer(major + 1, 0, 0)

            case PatchLevel.MINOR:
                return new SemVer(major, minor + 1, 0)

            case PatchLevel.PATCH:
                return new SemVer(major, minor, patch + 1)
        }
        return new SemVer()
    }

    String toString() {
        return "${major}.${minor}.${patch}"
    }
}

// Project version based on tags

import javax.naming.AuthenticationException
import org.ajoberstar.grgit.Grgit
import org.ajoberstar.grgit.Credentials

ext.projectVersionHelper = { snapshot=true ->
    def grgit = Grgit.open(dir: projectDir)
    def branch = grgit.branch.current().name

    // format: "TAG-DISTANCE-gHASH"
    def description = grgit.describe()

    // we default to 1.0.0 if no release exists so far
    def tag = "1.0.0"
    def hasVersion = false
    if (description != null) {
        tag = description.split("-")[0]
        hasVersion = true
    }
    if (branch == "master") {
        return tag
    }

    if (branch.startsWith("release/")) {
        return branch.substring("release/".length())
    }

    def semVer = new SemVer(tag)
    if (hasVersion) {
        semVer = semVer.bump(PatchLevel.PATCH)
    }

    def version = semVer.toString()

    def SN="-SNAPSHOT"
    if (snapshot == false) {
        SN=""
    }
    if (branch.startsWith("feature/")) {
        def feature = branch.substring("feature/".length())
        return "$version-$feature$SN"
    } 
    else if (branch.startsWith("PR-")) {
        return "$version-$branch$SN"
        
    }
    return "$version$SN"
}

ext.findDependencyVersion = { projectName, snapshot=true ->
    def grgit = Grgit.open(dir: file("../$projectName").absolutePath)
    def branch = grgit.branch.current().name

    // format: "TAG-DISTANCE-gHASH"
    def description = grgit.describe()

    // we default to 1.0.0 if no release exists so far
    def tag = "1.0.0"
    def hasVersion = false
    if (description != null) {
        tag = description.split("-")[0]
        hasVersion = true
    }

    def semVer = new SemVer(tag)

    def SN="-SNAPSHOT"
    if (snapshot == false) {
        SN=""
    }
    else if (hasVersion) {
        semVer = semVer.bump(PatchLevel.PATCH)
    }
    
    def version = semVer.toString()

    if (branch.startsWith("feature/")) {
        def feature = branch.substring("feature/".length())
        return "$version-$feature$SN"
    }
    return "$version$SN"
}

ext.readVersions = {
    def props = new Properties()
    file("versions.properties").withInputStream { props.load(it) }
    props.each { key, value ->
        project.ext[key] = value
    }
}

task updateVersions {
    doLast {
        if (project.hasProperty('projectDependencies') == false) {
            return
        }

        def fileContent = "# WARNING! This file will be overwritten by task 'updateVersions'"
        projectDependencies.split(',').each {
            def version = findDependencyVersion(it, project.version.contains("SNAPSHOT"))
            fileContent += "\n${it}Version=${version}"
        }
        new File(projectDir, "versions.properties").text = fileContent
    }
}

task releaseVersion {
    doLast {
        println projectVersionHelper(false)
    }
}

task dependencyReleaseVersions {
    doLast {
        if (project.hasProperty('projectDependencies') == false) {
            return
        }
        if (projectDependencies == null) {
            return
        }
        projectDependencies.split(',').each {
            println "${it}: ${findDependencyVersion(it, false)}"
        }
    }
}

task version {
    doLast {
        println project.version
    }
}
